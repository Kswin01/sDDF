var rx_cnt = @base;
var rx_remain = @base + 4;
var rx_tail = @base + 8;
var rx_head = @base + 12;
var rx_phys = @base + 16;
var rx_cookies = @base + 24;
var rx_descr = @base + 32;

var tx_cnt = @base + 40;
var tx_remain = @base + 44;
var tx_tail = @base + 48;
var tx_head = @base + 52;
var tx_phys = @base + 56;
var tx_cookies = @base + 64;
var tx_descr = @base + 72;

var argc_arr = @base + 80;
var arga_arr = @base + 81;
#get_channel(argc_ar, 0, arga_arr, 1);
var argc = ldb arga_arr;

// @base + 600 -> @base + 1634 -- reserved for tx_lengths array
var tx_lengths = @base + 600;

//base = 82

// Called from init entry point
if argc == 10 {
  rx_cnt = 256;
  rx_remain = 256 - 2;
  rx_tail = 0;
  rx_head = 0;

  var c_arr = @base + 82;
  #get_rx_phys(c_arr, 0, rx_phys, 8);
  #get_rx_cookies(c_arr, 0, rx_cookies, 8);
  #get_rx_descr(c_arr, 0, rx_descr, 8);

  tx_cnt = 256;
  tx_remain = 256 - 2;
  tx_tail = 0;
  tx_head = 0;

  #get_tx_phys(c_arr, 0, tx_phys, 8);
  #get_tx_cookies(c_arr, 0, tx_cookies, 8);
  #get_tx_descr(c_arr, 0, tx_cookies, 8);
}

//base = 83 - reuse the space c_arr above used

// INIT case from notified
if argc == 4 {
  var c_arr = @base + 83;
  var a_arr = @base + 84;
  #init_post(c_arr, 0, a_arr, 0);
  
  //fill_rx_bufs() function:

  #sychronise_call(c_arr, 0, a_arr, 0);
  while rx_remain > 0 {
      // Requesting a buffer
      var cookie = @base + 85;
      var phys = @base + 93;
      #alloc_rx_buff(cookie, 8, phys, 8);
      if phys <> 1 {
        break;
      }

      // This might not work if the machine word is 32 bits
      var stat = 1 << 58;
      var idx = rx_tail;
      var new_tail = idx + 1;
      if new_tail == rx_cnt {
        new_tail = 0;
        stat = stat | (1 << 13);
      }

      var set_cookie_c = @base + 101;
      var set_cookie_a = @base + 120;
      strb set_cookie_c, idx;

      // Setting bytes of cookie address
      strb set_cookie_c + 1, cookie;
      strb set_cookie_c + 2, cookie + 1;
      strb set_cookie_c + 3, cookie + 2;
      strb set_cookie_c + 4, cookie + 3;
      strb set_cookie_c + 5, cookie + 4;
      strb set_cookie_c + 6, cookie + 5;
      strb set_cookie_c + 7, cookie + 6;
      strb set_cookie_c + 8, cookie + 7;

      strb set_cookie_c + 9, rx_cookies;
      strb set_cookie_c + 10, rx_cookies + 1;
      strb set_cookie_c + 11, rx_cookies + 2;
      strb set_cookie_c + 12, rx_cookies + 3;
      strb set_cookie_c + 13, rx_cookies + 4;
      strb set_cookie_c + 14, rx_cookies + 5;
      strb set_cookie_c + 15, rx_cookies + 6;
      strb set_cookie_c + 16, rx_cookies + 7;

      #set_cookies(set_cookie_c, 17, set_cookie_a, 0);

      var update_c = @base + 120;
      var update_a = @base + 148;

      // Storing descriptor in 0-7
      strb update_c + 0, rx_descr;
      strb update_c + 1, rx_descr + 1;
      strb update_c + 2, rx_descr + 2;
      strb update_c + 3, rx_descr + 3;
      strb update_c + 4, rx_descr + 4;
      strb update_c + 5, rx_descr + 5;
      strb update_c + 6, rx_descr + 6;
      strb update_c + 7, rx_descr + 7;

      // Storing index in 8
      strb update_c + 8, index;

      // Storing phys in 9-16
      strb update_c + 9, phys;
      strb update_c + 10, phys + 1;
      strb update_c + 11, phys + 2;
      strb update_c + 12, phys + 3;
      strb update_c + 13, phys + 4;
      strb update_c + 14, phys + 5;
      strb update_c + 15, phys + 6;
      strb update_c + 16, phys + 7;

      // Storing len in 17
      strb update_c + 17, 0;

      // Storing stat in 18 - 25
      strb update_c + 18, stat;
      strb update_c + 19, stat + 1;
      strb update_c + 20, stat + 2;
      strb update_c + 21, stat + 3;
      strb update_c + 22, stat + 4;
      strb update_c + 23, stat + 5;
      strb update_c + 24, stat + 6;
      strb update_c + 25, stat + 7;

      #update_descr_slot(update_c, 26, update_a, 0);
      rx_tail = new_tail;
      rx_remain = rx_remain - 1;
  }

  // Not sure if ffi protocol checks if we passed through valid addresses
  #sychronise_call(0, 0, 0, 0);

  if (rx_tail <> rx_head) {
    #enable_rx(0,0,0,0);
  }

}

// Handle TX case
// Handle TX case
if argc == 2 {
  var dequeue_c = @base + 83;
  strb dequeue_c, 1;
  // dequeue_a will be 24 in size
  var dequeue_a = @base + 84;

  #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

  var driver_ret = ldb dequeue_c;

  var buffer = @base + 84;
  var len = @base + 92;
  var cookie = @base + 100;

  while tx_remain > 1 {
    if driver_dequeue == 1 {
      break;
    }

    var phys = @base + 108;
    #get_phys(buffer, 8, phys, 8);

    // Handle the raw_tx function here
    if rx_remain < 1 {
      // Complete TX function here
      var cnt_org = 0;
      var complete_cookie = @base + 130;
      var head = tx_head;
      var cnt = 0;

      while head <> rx_tail {
        if cnt == 0 {
          // Calculate offset into tx_lengths array
          var tx_index = tx_lengths;
          var tx_index_cnt = 0;
          while tx_index_cnt <= head {
            tx_index_cnt = tx_index_cnt + 4;
          }

          var cnt = ldb tx_index;

          // Error cases
          if cnt == 0 {
            return 1;
          }

          if cnt > 256 {
            return 1;
          }

          cnt_org = cnt;

          // Get the cookie
          var get_cookie_c = @base + 138;
          var get_cookie_a = @base + 148;
          strb get_cookie_c, head;

          strb get_cookie_c + 1, tx_cookies;
          strb get_cookie_c + 2, tx_cookies + 1;
          strb get_cookie_c + 3, tx_cookies + 2;
          strb get_cookie_c + 4, tx_cookies + 3;
          strb get_cookie_c + 5, tx_cookies + 4;
          strb get_cookie_c + 6, tx_cookies + 5;
          strb get_cookie_c + 7, tx_cookies + 6;
          strb get_cookie_c + 8, tx_cookies + 7;

          #get_cookies(get_cookie_c, 9, get_cookie_a, 0);

          strb complete_cookie, get_cookie_c + 1;
          strb complete_cookie + 1, get_cookie_c + 2;
          strb complete_cookie + 2, get_cookie_c + 3;
          strb complete_cookie + 3, get_cookie_c + 4;
          strb complete_cookie + 4, get_cookie_c + 5;
          strb complete_cookie + 5, get_cookie_c + 6;
          strb complete_cookie + 6, get_cookie_c + 7;
          strb complete_cookie + 7, get_cookie_c + 8;

          // Try and release buffer, need to pass cookie to ffi call
          var buffer_release_c = @base + 150;
          var buffer_release_a = @base + 159;

          strb buffer_release_c, tx_descr;
          strb buffer_release_c + 1, tx_descr + 1;
          strb buffer_release_c + 2, tx_descr + 2;
          strb buffer_release_c + 3, tx_descr + 3;
          strb buffer_release_c + 4, tx_descr + 4;
          strb buffer_release_c + 5, tx_descr + 5;
          strb buffer_release_c + 6, tx_descr + 6;
          strb buffer_release_c + 7, tx_descr + 7;

          strb buffer_release_c + 8, head;

          #try_buffer_release(buffer_release_c, 9, buffer_release_a, 1);
          var try_ret = ldb buffer_release_a;
          
          // Can't release buffer
          if try_ret <> 0 {
            return 1;
          }

          // Handling rollover
          head = head + 1;
          if head == 256 {
            head = 0;
          }
          
          if cnt == 0 {
            cnt = cnt - 1;
            rx_head = head;
            rx_remain = rx_remain + 1;
            var driver_enqueue_c = @base + 150;
            var driver_enqueue_a = @base + 158;

            // Place cookie into c array and enqueue the buffer it holds back into the control region
            strb driver_enqueue_c, complete_cookie;
            strb driver_enqueue_c + 1, complete_cookie + 1;
            strb driver_enqueue_c + 2, complete_cookie + 2;
            strb driver_enqueue_c + 3, complete_cookie + 3;
            strb driver_enqueue_c + 4, complete_cookie + 4;
            strb driver_enqueue_c + 5, complete_cookie + 5;
            strb driver_enqueue_c + 6, complete_cookie + 6;
            strb driver_enqueue_c + 7, complete_cookie + 7;

            #eth_driver_enqueue_avail(driver_enqueue_c, 8, driver_enqueue_a, 0);
          }

        }
      }

      if rx_remain < 1 {
        // TX queue lacks space
        return 1;
      }

    }

    #sychronise_call(0,0,0,0);
    var tail = rx_tail;
    var tail_new = tail;
    var i = 1;
    while i > 0 {
      i = i - 1;
      var stat = (1 << 15);
      if i == 0 {
        stat = stat | (1 << 10) | (1 << 11);
      }

      var index = tail_new;
      var temp_tail = tail_new + 1;
      if temp_tail == 256 {
        tail_new = 0;
        stat = stat | (1 << 13);
      } 

      // update the ring slot
      var update_c = @base + 150;
      var update_a = @base + 148;

      // Storing descriptor in 0-7
      strb update_c + 0, tx_descr;
      strb update_c + 1, tx_descr + 1;
      strb update_c + 2, tx_descr + 2;
      strb update_c + 3, tx_descr + 3;
      strb update_c + 4, tx_descr + 4;
      strb update_c + 5, tx_descr + 5;
      strb update_c + 6, tx_descr + 6;
      strb update_c + 7, tx_descr + 7;

      // Storing index in 8
      strb update_c + 8, index;

      // Storing phys in 9-16
      strb update_c + 9, phys;
      strb update_c + 10, phys + 1;
      strb update_c + 11, phys + 2;
      strb update_c + 12, phys + 3;
      strb update_c + 13, phys + 4;
      strb update_c + 14, phys + 5;
      strb update_c + 15, phys + 6;
      strb update_c + 16, phys + 7;

      // Storing len in 17
      strb update_c + 17, 0;

      // Storing stat in 18 - 25
      strb update_c + 18, stat;
      strb update_c + 19, stat + 1;
      strb update_c + 20, stat + 2;
      strb update_c + 21, stat + 3;
      strb update_c + 22, stat + 4;
      strb update_c + 23, stat + 5;
      strb update_c + 24, stat + 6;
      strb update_c + 25, stat + 7;

      #update_descr_slot(update_c, 26, update_a, 0);
      // We want to increment len here
      len = len + 1;  

    }

    // Set the cookie 
    var set_cookie_c = @base + 109;
    var set_cookie_a = @base + 126;
    strb set_cookie_c, index;

    // Setting bytes of cookie address
    strb set_cookie_c + 1, cookie;
    strb set_cookie_c + 2, cookie + 1;
    strb set_cookie_c + 3, cookie + 2;
    strb set_cookie_c + 4, cookie + 3;
    strb set_cookie_c + 5, cookie + 4;
    strb set_cookie_c + 6, cookie + 5;
    strb set_cookie_c + 7, cookie + 6;
    strb set_cookie_c + 8, cookie + 7;

    strb set_cookie_c + 9, tx_cookies;
    strb set_cookie_c + 10, tx_cookies + 1;
    strb set_cookie_c + 11, tx_cookies + 2;
    strb set_cookie_c + 12, tx_cookies + 3;
    strb set_cookie_c + 13, tx_cookies + 4;
    strb set_cookie_c + 14, tx_cookies + 5;
    strb set_cookie_c + 15, tx_cookies + 6;
    strb set_cookie_c + 16, tx_cookies + 7;

    #set_cookies(set_cookie_c, 17, set_cookie_a, 0);

    // Need to update the tx_length here

    tx_tail = tail_new;
    tx_remain = tx_remain - 1;

    var tx_index = tx_length;
    var pointer_increase = 0;
    while pointer_increase < tail_new {
        tx_index = tx_index + 4;
    }

    strb tx_index, 1;

    #synchronise_call(0,0,0,0);
    #tx_descr_active(0,0,0,0);

    // Dequeue another buffer to service
    // var dequeue_c = @base + 83;
    strb dequeue_c, 1;
    // dequeue_a will be 24 in size
    // var dequeue_a = @base + 84;

    #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

    driver_ret = ldb dequeue_c;
  }

}

// Handle eth case - use heap addresses above + 200
if argc == 1 {
  var irq_c = @base + 200;
  var irq_a = @base + 201;
  #get_irq(irq_c, 0, irq_a, 4);

  var irq_num_1 = (ldb irq_a) << 24;
  var irq_num_2 = (ldb irq_a + 1) << 16;
  var irq_num_3 = (ldb irq_a + 2) << 8;
  var irq_num_4 = (ldb irq_a + 3);

  var e = irq_num_1 | irq_num_2 | irq_num_3 | irq_num_4;

  var irq_mask = (1 << 25) | (1 << 27) | (1 << 22);

  while e & irq_mask == 1 {
    if e & (1 << 27) {
      // Complete TX here
            var cnt_org = 0;
      var complete_cookie = @base + 130;
      var head = tx_head;
      var cnt = 0;

      while head <> rx_tail {
        if cnt == 0 {
          // Calculate offset into tx_lengths array
          var tx_index = tx_lengths;
          var tx_index_cnt = 0;
          while tx_index_cnt <= head {
            tx_index_cnt = tx_index_cnt + 4;
          }

          var cnt = ldb tx_index;

          // Error cases
          if cnt == 0 {
            return 1;
          }

          if cnt > 256 {
            return 1;
          }

          cnt_org = cnt;

          // Get the cookie
          var get_cookie_c = @base + 138;
          var get_cookie_a = @base + 148;
          strb get_cookie_c, head;

          strb get_cookie_c + 1, tx_cookies;
          strb get_cookie_c + 2, tx_cookies + 1;
          strb get_cookie_c + 3, tx_cookies + 2;
          strb get_cookie_c + 4, tx_cookies + 3;
          strb get_cookie_c + 5, tx_cookies + 4;
          strb get_cookie_c + 6, tx_cookies + 5;
          strb get_cookie_c + 7, tx_cookies + 6;
          strb get_cookie_c + 8, tx_cookies + 7;

          #get_cookies(get_cookie_c, 9, get_cookie_a, 0);

          strb complete_cookie, get_cookie_c + 1;
          strb complete_cookie + 1, get_cookie_c + 2;
          strb complete_cookie + 2, get_cookie_c + 3;
          strb complete_cookie + 3, get_cookie_c + 4;
          strb complete_cookie + 4, get_cookie_c + 5;
          strb complete_cookie + 5, get_cookie_c + 6;
          strb complete_cookie + 6, get_cookie_c + 7;
          strb complete_cookie + 7, get_cookie_c + 8;

          // Try and release buffer, need to pass cookie to ffi call
          var buffer_release_c = @base + 150;
          var buffer_release_a = @base + 159;

          strb buffer_release_c, tx_descr;
          strb buffer_release_c + 1, tx_descr + 1;
          strb buffer_release_c + 2, tx_descr + 2;
          strb buffer_release_c + 3, tx_descr + 3;
          strb buffer_release_c + 4, tx_descr + 4;
          strb buffer_release_c + 5, tx_descr + 5;
          strb buffer_release_c + 6, tx_descr + 6;
          strb buffer_release_c + 7, tx_descr + 7;

          strb buffer_release_c + 8, head;

          #try_buffer_release(buffer_release_c, 9, buffer_release_a, 1);
          var try_ret = ldb buffer_release_a;
          
          // Can't release buffer
          if try_ret <> 0 {
            return 1;
          }

          // Handling rollover
          head = head + 1;
          if head == 256 {
            head = 0;
          }
          
          if cnt == 0 {
            cnt = cnt - 1;
            rx_head = head;
            rx_remain = rx_remain + 1;
            var driver_enqueue_c = @base + 150;
            var driver_enqueue_a = @base + 158;

            // Place cookie into c array and enqueue the buffer it holds back into the control region
            strb driver_enqueue_c, complete_cookie;
            strb driver_enqueue_c + 1, complete_cookie + 1;
            strb driver_enqueue_c + 2, complete_cookie + 2;
            strb driver_enqueue_c + 3, complete_cookie + 3;
            strb driver_enqueue_c + 4, complete_cookie + 4;
            strb driver_enqueue_c + 5, complete_cookie + 5;
            strb driver_enqueue_c + 6, complete_cookie + 6;
            strb driver_enqueue_c + 7, complete_cookie + 7;

            #eth_driver_enqueue_avail(driver_enqueue_c, 8, driver_enqueue_a, 0);
          }
        }
      }
    }

    if e & (1 << 25) {
      // Handle RX

      // Fill RX buf 
      i = i + 1;
    }

    if e & (1 << 22) {
      // Error here, infinitely loop
      while 1 == 1 {
        i = 1;
      }
    }
  }

}

return 0;