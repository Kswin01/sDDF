var get_rx_c = @base + 8;
var get_rx_a = @base + 16;
var get_tx_c = @base + 24;
var get_tx_a = @base + 32;

#get_rx_vals(get_rx_c, 0, get_rx_a, 4);
#get_tx_vals(get_tx_c, 0, get_tx_a, 4);

var rx_cnt = ldb get_rx_a;
var rx_remain = ldb get_rx_a + 1;
var rx_tail = ldb get_rx_a + 2;
var rx_head = ldb get_rx_a + 3;

var tx_cnt = ldb get_tx_a;
var tx_remain = ldb get_tx_a + 1;
var tx_tail = ldb get_tx_a + 2;
var tx_head = ldb get_tx_a + 3;

var set_rx_c = @base + 400;
var set_rx_a = @base + 408;

var set_tx_c = @base + 416;
var set_tx_a = @base + 424;

// Set tx and rx
strb set_rx_c, rx_cnt;
strb set_rx_c + 1, rx_remain;
strb set_rx_c + 2, rx_tail;
strb set_rx_c + 3, rx_head;

#store_rx_vals(set_rx_c, 4, set_rx_a, 0);

strb set_tx_c, tx_cnt;
strb set_tx_c + 1, tx_remain;
strb set_tx_c + 2, tx_tail;
strb set_tx_c + 3, tx_head;

#store_tx_vals(set_tx_c, 4, set_tx_c, 0);

var argc_arr = @base + 80;
var arga_arr = @base + 81;
#get_channel(argc_ar, 0, arga_arr, 1);
var argc = ldb arga_arr;

// @base + 600 -> @base + 855 -- reserved for tx_lengths array
var tx_lengths = @base + 500;

// Handle TX case
if argc == 2 {
  var dequeue_c = @base + 83;
  strb dequeue_c, 1;
  // dequeue_a will be 24 in size
  var dequeue_a = @base + 84;

  #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

  var driver_ret = ldb dequeue_c;

  var buffer = @base + 84;
  var len = @base + 92;
  var cookie = @base + 100;

  // Copy over the buffer, buffer len and the cookie
  strb buffer, ldb dequeue_a;
  strb buffer + 1, ldb dequeue_a + 1;
  strb buffer + 2, ldb dequeue_a + 2;
  strb buffer + 3, ldb dequeue_a + 3;
  strb buffer + 4, ldb dequeue_a + 4;
  strb buffer + 5, ldb dequeue_a + 5;
  strb buffer + 6, ldb dequeue_a + 6;
  strb buffer + 7, ldb dequeue_a + 7;

  strb len, ldb dequeue_a + 8;
  strb len + 1, ldb dequeue_a + 9;
  strb len + 2, ldb dequeue_a + 10;
  strb len + 3, ldb dequeue_a + 11;
  strb len + 4, ldb dequeue_a + 12;
  strb len + 5, ldb dequeue_a + 13;
  strb len + 6, ldb dequeue_a + 14;
  strb len + 7, ldb dequeue_a + 15;

  strb cookie, ldb dequeue_a + 16;
  strb cookie + 1, ldb dequeue_a + 17;
  strb cookie + 2, ldb dequeue_a + 18;
  strb cookie + 3, ldb dequeue_a + 19;
  strb cookie + 4, ldb dequeue_a + 20;
  strb cookie + 5, ldb dequeue_a + 21;
  strb cookie + 6, ldb dequeue_a + 22;
  strb cookie + 7, ldb dequeue_a + 23;


  while tx_remain > 1 {
    #dummy_call(0,0,0,0);
    if driver_ret <> 0 {
      #break_loop(0,0,0,0);
      break;
    }

    var phys = @base + 108;
    #get_phys(buffer, 8, phys, 8);

    // Handle the raw_tx function here

    if tx_remain < 1 {
      #breakpoint_1(0,0,0,0);
      return 1;
    }

    #synchronise_call(0,0,0,0);
    var tail = tx_tail;
    var tail_new = tail;
    var i = 1;
    
    while i > 0 {
      var stat_c = @base;
      #in_loop(0,0,0,0);
      i = i - 1;
      var stat = 1 << 15;
      strb stat_c + 1, (stat) & 255;
      strb stat_c, (stat >> 8) & 255;
      #print_stat(stat_c, 1,0,0);
      if i == 0 {
        #in_conditional(0,0,0,0);
        stat = stat | (1 << 10) | (1 << 11);
        strb stat_c + 1, (stat) & 255;
        strb stat_c, (stat >> 8) & 255;
        #print_stat(stat_c, 1,0,0);
      }

      var index = tail_new;
      var temp_tail = tail_new + 1;

      if temp_tail == 255 {
        tail_new = 0;
        stat = stat | (1 << 13);
        strb stat_c + 1, (stat) & 255;
        strb stat_c, (stat >> 8) & 255;
        #breakpoint_1(0,0,0,0);
        #in_conditional(0,0,0,0);
        #print_stat(stat_c, 1,0,0);
      } else {
        #in_else(0,0,0,0);
        tail_new = tail_new + 1;
      }

      // update the ring slot
      var update_c = @base + 150;
      var update_a = @base + 148;

      // Storing descriptor in 0-7
      strb update_c + 0, 0;
      // Storing index in 8
      strb update_c + 8, index;


      // Storing phys in 9-16
      strb update_c + 9, ldb phys;
      strb update_c + 10, ldb phys + 1;
      strb update_c + 11, ldb phys + 2;
      strb update_c + 12, ldb phys + 3;
      strb update_c + 13, ldb phys + 4;
      strb update_c + 14, ldb phys + 5;
      strb update_c + 15, ldb phys + 6;
      strb update_c + 16, ldb phys + 7;


      // Storing len in 17
      strb update_c + 17, ldb len;
      strb update_c + 18, ldb len + 1;
      strb update_c + 19, ldb len + 2;
      strb update_c + 20, ldb len + 3;
      strb update_c + 21, ldb len + 4;
      strb update_c + 22, ldb len + 5;
      strb update_c + 23, ldb len + 6;
      strb update_c + 24, ldb len + 7;


      // Storing stat in 18 - 25
      strb update_c + 26, (stat) & 255;
      strb update_c + 25, (stat >> 8) & 255;


      #update_descr_slot_raw_tx(update_c, 32, update_a, 0);

      // Saving phys from 9-16
      strb phys, ldb update_c + 9;
      strb phys + 1, ldb update_c + 10;
      strb phys + 2, ldb update_c + 11;
      strb phys + 3, ldb update_c + 12;
      strb phys + 4, ldb update_c + 13;
      strb phys + 5, ldb update_c + 14;
      strb phys + 6, ldb update_c + 15;
      strb phys + 7, ldb update_c + 16;

      // Saving len from 17
      strb len, ldb update_c + 17;
      strb len + 1, ldb update_c + 18;
      strb len + 2, ldb update_c + 19;
      strb len + 3, ldb update_c + 20;
      strb len + 4, ldb update_c + 21;
      strb len + 5, ldb update_c + 22;
      strb len + 6, ldb update_c + 23;
      strb len + 7, ldb update_c + 24;

      
      // End raw TX Function
    }

    // Set the cookie 
    var ring_var_c = @base + 109;
    var ring_var_a = @base + 126;
    strb ring_var_c, tail;
    strb ring_var_c + 1, tail_new;

    // Setting bytes of cookie address
    strb ring_var_c + 2, ldb cookie;
    strb ring_var_c + 3, ldb cookie + 1;
    strb ring_var_c + 4, ldb cookie + 2;
    strb ring_var_c + 5, ldb cookie + 3;
    strb ring_var_c + 6, ldb cookie + 4;
    strb ring_var_c + 7, ldb cookie + 5;
    strb ring_var_c + 8, ldb cookie + 6;
    strb ring_var_c + 9, ldb cookie + 7;

    #update_ring_var(ring_var_c, 0, ring_var_a, 0);


    #breakpoint_1(0,0,0,0);

    // Dequeue another buffer to service
    // var dequeue_c = @base + 83;
    strb dequeue_c, 1;
    // dequeue_a will be 24 in size
    // var dequeue_a = @base + 84;

    #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

    // Copy over the buffer, buffer len and the cookie
    strb buffer, ldb dequeue_a;
    strb buffer + 1, ldb dequeue_a + 1;
    strb buffer + 2, ldb dequeue_a + 2;
    strb buffer + 3, ldb dequeue_a + 3;
    strb buffer + 4, ldb dequeue_a + 4;
    strb buffer + 5, ldb dequeue_a + 5;
    strb buffer + 6, ldb dequeue_a + 6;
    strb buffer + 7, ldb dequeue_a + 7;

    strb len, ldb dequeue_a + 8;
    strb len + 1, ldb dequeue_a + 9;
    strb len + 2, ldb dequeue_a + 10;
    strb len + 3, ldb dequeue_a + 11;
    strb len + 4, ldb dequeue_a + 12;
    strb len + 5, ldb dequeue_a + 13;
    strb len + 6, ldb dequeue_a + 14;
    strb len + 7, ldb dequeue_a + 15;

    strb cookie, ldb dequeue_a + 16;
    strb cookie + 1, ldb dequeue_a + 17;
    strb cookie + 2, ldb dequeue_a + 18;
    strb cookie + 3, ldb dequeue_a + 19;
    strb cookie + 4, ldb dequeue_a + 20;
    strb cookie + 5, ldb dequeue_a + 21;
    strb cookie + 6, ldb dequeue_a + 22;
    strb cookie + 7, ldb dequeue_a + 23;

    driver_ret = ldb dequeue_c;
  }

  #returning(0,0,0,0);
  return 0;
}

// Handle eth case - use heap addresses above + 200
if argc == 1 {
  var irq_c = @base + 200;
  var irq_a = @base + 201;
  #get_irq(irq_c, 0, irq_a, 4);

  var irq_num_1 = (ldb irq_a) << 24;
  var irq_num_2 = (ldb irq_a + 1) << 16;
  var irq_num_3 = (ldb irq_a + 2) << 8;
  var irq_num_4 = (ldb irq_a + 3);

  var e = irq_num_1 | irq_num_2 | irq_num_3 | irq_num_4;

  var NETIRQ_RXF = (1 << 25);
  var NETIRQ_TXF = (1 << 27);
  var NETIRQ_EBERR = (1 << 22);

  var irq_mask = NETIRQ_RXF | NETIRQ_TXF | NETIRQ_EBERR;

  var print_e_c = @base + 900;
  strb print_e_c, (e >> 24) & 255;
  strb print_e_c + 1, (e >> 16) & 255;
  strb print_e_c + 2, (e >> 8) & 255;
  strb print_e_c + 3, e & 255;

  strb print_e_c + 4, (irq_mask >> 24) & 255;
  strb print_e_c + 5, (irq_mask >> 16) & 255;
  strb print_e_c + 6, (irq_mask >> 8) & 255;
  strb print_e_c + 7, irq_mask & 255;

  #print_e(print_e_c, 0,0,0);

  var e_result = e & irq_mask;

  strb print_e_c, (e_result >> 24) & 255;
  strb print_e_c + 1, (e_result >> 16) & 255;
  strb print_e_c + 2, (e_result >> 8) & 255;
  strb print_e_c + 3, e_result & 255;
  
  #print_e_res(print_e_c, 0,0,0);

  while (e & irq_mask) <> 0 {
    #in_loop(0,0,0,0);
    if (e & (1 << 27)) <> 0 {
      #print_eth_firstcase(0,0,0,0);
      set_rx_c = @base + 400;
      set_rx_a = @base + 408;

      set_tx_c = @base + 416;
      set_tx_a = @base + 424;

      // Set tx and rx
      strb set_rx_c, rx_cnt;
      strb set_rx_c + 1, rx_remain;
      strb set_rx_c + 2, rx_tail;
      strb set_rx_c + 3, rx_head;

      #store_rx_vals(set_rx_c, 4, set_rx_a, 0);

      strb set_tx_c, tx_cnt;
      strb set_tx_c + 1, tx_remain;
      strb set_tx_c + 2, tx_tail;
      strb set_tx_c + 3, tx_head;

      #store_tx_vals(set_tx_c, 4, set_tx_c, 0);

      #complete_tx(0,0,0,0);

      // Get tx and rx
      get_rx_c = @base + 16;
      get_rx_a = @base + 20;
      get_tx_c = @base + 16;
      get_tx_a = @base + 20;

      #get_rx_vals(get_rx_c, 0, get_rx_a, 4);
      #get_tx_vals(get_tx_c, 0, get_tx_a, 4);

      rx_cnt = ldb get_rx_a;
      rx_remain = ldb get_rx_a + 1;
      rx_tail = ldb get_rx_a + 2;
      rx_head = ldb get_rx_a + 3;

      tx_cnt = ldb get_tx_a;
      tx_remain = ldb get_tx_a + 1;
      tx_tail = ldb get_tx_a + 2;
      tx_head = ldb get_tx_a + 3;

    }

    // Use addresses starting from 300
    if (e & (1 << 25)) <> 0 {
      #print_eth_secondcase(0,0,0,0);
      // Handle RX

      var get_head_a = @base + 1;
      #get_rx_head(0, 0, get_head_a, 1);
      head = ldb get_head_a;
      var num = 1;
      
      // Check if the ring is empty
      var ring_empty_c = @base + 300;
      var ring_empty_a = @base + 301;
      #eth_ring_empty(ring_empty_c, 0, ring_empty_a, 1);
      var was_empty = ldb ring_empty_a;
      var ring_empty_ret = ldb ring_empty_a;

      // Get the current ring size
      var ring_size_c = @base + 302;
      var ring_size_a = @base + 303;
      #eth_ring_size(ring_size_c, 0, ring_size_a, 1);
      var ring_size = ldb ring_size_a;
      
      while head <> rx_tail {
        #in_loop(0,0,0,0);
        if ring_size <= num {
          #break_loop(0,0,0,0);
          break;
        }

        // Check if the slot is marked as empty
        var check_empty_c = @base + 304;
        var check_empty_a = @base + 313;

        strb check_empty_c, 0;
        strb check_empty_c + 1, head;

        #check_empty(check_empty_c, 9, check_empty_a, 1);

        var check_empty_ret = ldb check_empty_a;
        
        if check_empty_ret == 1 {
          break;
        } 

        // Reuse the check empty argument arrays to get the len of the descriptor

        #get_descr_len(check_empty_c, 9, check_empty_a, 1);

        var descr_len = @base + 800;

        strb descr_len, ldb check_empty_c;
        strb descr_len + 1, ldb check_empty_c + 1;

        // Get the cookie at index head
        var get_cookie_c = @base + 314;
        var get_cookie_a = @base + 323;

        strb get_cookie_c, head;
        strb get_cookie_c + 1, 1;

        #get_cookies(get_cookie_c, 9, get_cookie_a, 0);
        
        // The cookie will be stored in get_cookie_c

        head = head + 1;
        
        var get_rx_cnt = @base + 2;
        #get_rx_count(0,0,get_rx_cnt, 1);

        rx_cnt = ldb get_rx_cnt;

        if head == rx_cnt {
          head = 0;
        }

        // var set_head_c = @base;
        // strb set_head_c, head;
        // #set_rx_head(set_head_c, 1, 0, 0);

        // #increment_rx_remain(0,0,0,0);

        var rx_enqueue_c = @base + 324;
        var rx_enqueue_a = @base + 333;

        strb rx_enqueue_c, ldb get_cookie_c;
        strb rx_enqueue_c + 1, ldb get_cookie_c + 1;
        strb rx_enqueue_c + 2, ldb get_cookie_c + 2;
        strb rx_enqueue_c + 3, ldb get_cookie_c + 3;
        strb rx_enqueue_c + 4, ldb get_cookie_c + 4;
        strb rx_enqueue_c + 5, ldb get_cookie_c + 5;
        strb rx_enqueue_c + 6, ldb get_cookie_c + 6;
        strb rx_enqueue_c + 7, ldb get_cookie_c + 7;

        strb rx_enqueue_c + 8, ldb descr_len;
        strb rx_enqueue_c + 9, ldb descr_len + 1;
        strb rx_enqueue_c + 10, head;

        #eth_driver_enqueue_used(rx_enqueue_c, 8, rx_enqueue_a, 0);

        num = num + 1;

        #eth_ring_size(ring_size_c, 0, ring_size_a, 1);
        ring_size = ldb ring_size_a;
      }

      // Notify the client only if we have actually processed a packet. Not sure how this will work with pancake
      if num > 1 {
        if was_empty == 1 {
          #notify_rx(0,0,0,0);
        }
      }

      #breakpoint_1(0,0,0,0);

      // Fill RX buf 
      #fill_rx_bufs(0,0,0,0);

      // Need to get the latest rx values

      #finished_second_case(0,0,0,0);
    }

    if (e & (1 << 22)) <> 0 {
      #print_eth_thirdcase(0,0,0,0);
      // Error here, infinitely loop
      while 1 == 1 {
        i = 1;
      }
    }
    // Get next IRQ here
    #get_irq(irq_c, 0, irq_a, 4);

    irq_num_1 = (ldb irq_a) << 24;
    irq_num_2 = (ldb irq_a + 1) << 16;
    irq_num_3 = (ldb irq_a + 2) << 8;
    irq_num_4 = (ldb irq_a + 3);

    e = irq_num_1 | irq_num_2 | irq_num_3 | irq_num_4;
  }

}

return 0;