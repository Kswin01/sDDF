var get_rx_c = @base + 16;
var get_rx_a = @base + 20;
#get_rx_vals(get_rx_c, 0, get_rx_a, 4);

var get_tx_c = @base + 16;
var get_tx_a = @base + 20;

#get_tx_vals(get_tx_c, 0, get_tx_a, 4);

var rx_cnt = ldb get_rx_a;
var rx_remain = ldb get_rx_a + 1;
var rx_tail = ldb get_rx_a + 2;
var rx_head = ldb get_rx_a + 3;

var tx_cnt = ldb get_tx_a;
var tx_remain = ldb get_tx_a + 1;
var tx_tail = ldb get_tx_a + 2;
var tx_head = ldb get_tx_a + 3;

var argc_arr = @base + 80;
var arga_arr = @base + 81;
#get_channel(argc_ar, 0, arga_arr, 1);
var argc = ldb arga_arr;

// @base + 600 -> @base + 1634 -- reserved for tx_lengths array
var tx_lengths = @base + 500;

// Handle TX case
if argc == 2 {
  var dequeue_c = @base + 83;
  strb dequeue_c, 1;
  // dequeue_a will be 24 in size
  var dequeue_a = @base + 84;

  #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

  var driver_ret = ldb dequeue_c;

  var buffer = @base + 84;
  var len = @base + 92;
  var cookie = @base + 100;

  // Copy over the buffer, buffer len and the cookie
  strb buffer, ldb dequeue_a;
  strb buffer + 1, ldb dequeue_a + 1;
  strb buffer + 2, ldb dequeue_a + 2;
  strb buffer + 3, ldb dequeue_a + 3;
  strb buffer + 4, ldb dequeue_a + 4;
  strb buffer + 5, ldb dequeue_a + 5;
  strb buffer + 6, ldb dequeue_a + 6;
  strb buffer + 7, ldb dequeue_a + 7;

  strb len, ldb dequeue_a + 8;
  strb len + 1, ldb dequeue_a + 9;
  strb len + 2, ldb dequeue_a + 10;
  strb len + 3, ldb dequeue_a + 11;
  strb len + 4, ldb dequeue_a + 12;
  strb len + 5, ldb dequeue_a + 13;
  strb len + 6, ldb dequeue_a + 14;
  strb len + 7, ldb dequeue_a + 15;

  strb cookie, ldb dequeue_a + 16;
  strb cookie + 1, ldb dequeue_a + 17;
  strb cookie + 2, ldb dequeue_a + 18;
  strb cookie + 3, ldb dequeue_a + 19;
  strb cookie + 4, ldb dequeue_a + 20;
  strb cookie + 5, ldb dequeue_a + 21;
  strb cookie + 6, ldb dequeue_a + 22;
  strb cookie + 7, ldb dequeue_a + 23;


  while tx_remain > 1 {
    #dummy_call(0,0,0,0);
    if driver_ret <> 0 {
        #break_loop(0,0,0,0);
      break;
    }

    // Temp use phys_a

    var phys = @base + 108;
    #get_phys(buffer, 8, phys, 8);

    // Handle the raw_tx function here

    // base + 150
    var ffi_raw_tx_c = @base + 150; 
    var ffi_raw_tx_a = @base + 200;
    
    strb ffi_raw_tx_c, 1;
    strb ffi_raw_tx_c + 1, 0;

    strb ffi_raw_tx_c + 2, ldb buffer;
    strb ffi_raw_tx_c + 3, ldb buffer + 1;
    strb ffi_raw_tx_c + 4, ldb buffer + 2;
    strb ffi_raw_tx_c + 5, ldb buffer + 3;
    strb ffi_raw_tx_c + 6, ldb buffer + 4;
    strb ffi_raw_tx_c + 7, ldb buffer + 5;
    strb ffi_raw_tx_c + 8, ldb buffer + 6;
    strb ffi_raw_tx_c + 9, ldb buffer + 7;

    strb ffi_raw_tx_c + 10, ldb len;
    strb ffi_raw_tx_c + 11, ldb len + 1;
    strb ffi_raw_tx_c + 12, ldb len + 2;
    strb ffi_raw_tx_c + 13, ldb len + 3;
    strb ffi_raw_tx_c + 14, ldb len + 4;
    strb ffi_raw_tx_c + 15, ldb len + 5;
    strb ffi_raw_tx_c + 16, ldb len + 6;
    strb ffi_raw_tx_c + 17, ldb len + 7;

    strb ffi_raw_tx_c + 18, ldb cookie;
    strb ffi_raw_tx_c + 19, ldb cookie + 1;
    strb ffi_raw_tx_c + 20, ldb cookie + 2;
    strb ffi_raw_tx_c + 21, ldb cookie + 3;
    strb ffi_raw_tx_c + 22, ldb cookie + 4;
    strb ffi_raw_tx_c + 23, ldb cookie + 5;
    strb ffi_raw_tx_c + 24, ldb cookie + 6;
    strb ffi_raw_tx_c + 25, ldb cookie + 7;

    #raw_tx_sync_region(ffi_raw_tx_c, 26, ffi_raw_tx_a, 0);

      #breakpoint_1(0,0,0,0);

    // Dequeue another buffer to service
    // var dequeue_c = @base + 83;
    strb dequeue_c, 1;
    // dequeue_a will be 24 in size
    // var dequeue_a = @base + 84;

    #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

    // Copy over the buffer, buffer len and the cookie
    strb buffer, ldb dequeue_a;
    strb buffer + 1, ldb dequeue_a + 1;
    strb buffer + 2, ldb dequeue_a + 2;
    strb buffer + 3, ldb dequeue_a + 3;
    strb buffer + 4, ldb dequeue_a + 4;
    strb buffer + 5, ldb dequeue_a + 5;
    strb buffer + 6, ldb dequeue_a + 6;
    strb buffer + 7, ldb dequeue_a + 7;

    strb len, ldb dequeue_a + 8;
    strb len + 1, ldb dequeue_a + 9;
    strb len + 2, ldb dequeue_a + 10;
    strb len + 3, ldb dequeue_a + 11;
    strb len + 4, ldb dequeue_a + 12;
    strb len + 5, ldb dequeue_a + 13;
    strb len + 6, ldb dequeue_a + 14;
    strb len + 7, ldb dequeue_a + 15;

    strb cookie, ldb dequeue_a + 16;
    strb cookie + 1, ldb dequeue_a + 17;
    strb cookie + 2, ldb dequeue_a + 18;
    strb cookie + 3, ldb dequeue_a + 19;
    strb cookie + 4, ldb dequeue_a + 20;
    strb cookie + 5, ldb dequeue_a + 21;
    strb cookie + 6, ldb dequeue_a + 22;
    strb cookie + 7, ldb dequeue_a + 23;

    driver_ret = ldb dequeue_c;
  }

}

// Handle eth case - use heap addresses above + 200
if argc == 1 {
  var irq_c = @base + 200;
  var irq_a = @base + 201;
  #get_irq(irq_c, 0, irq_a, 4);

  var irq_num_1 = (ldb irq_a) << 24;
  var irq_num_2 = (ldb irq_a + 1) << 16;
  var irq_num_3 = (ldb irq_a + 2) << 8;
  var irq_num_4 = (ldb irq_a + 3);

  var e = irq_num_1 | irq_num_2 | irq_num_3 | irq_num_4;

  var irq_mask = (1 << 25) | (1 << 27) | (1 << 22);

  while e & irq_mask == 1 {
    if e & (1 << 27) {
      // Complete TX here
      var cnt_org = 0;
      var complete_cookie = @base + 130;
      var head = tx_head;
      var cnt = 0;

      while head <> rx_tail {
        if cnt == 0 {
          // Calculate offset into tx_lengths array
          var tx_index = tx_lengths;
          var tx_index_cnt = 0;
          while tx_index_cnt <= head {
            tx_index_cnt = tx_index_cnt + 4;
          }

          var cnt = ldb tx_index;

          // Error cases
          if cnt == 0 {
            return 1;
          }

          if cnt > 256 {
            return 1;
          }

          cnt_org = cnt;

          // Get the cookie
          var get_cookie_c = @base + 138;
          var get_cookie_a = @base + 148;
          strb get_cookie_c, head;

          strb get_cookie_c + 1, 0;

          #get_cookies(get_cookie_c, 9, get_cookie_a, 0);

          strb complete_cookie,ldb get_cookie_c + 1;
          strb complete_cookie + 1, ldb get_cookie_c + 2;
          strb complete_cookie + 2, ldb get_cookie_c + 3;
          strb complete_cookie + 3, ldb get_cookie_c + 4;
          strb complete_cookie + 4, ldb get_cookie_c + 5;
          strb complete_cookie + 5, ldb get_cookie_c + 6;
          strb complete_cookie + 6, ldb get_cookie_c + 7;
          strb complete_cookie + 7, ldb get_cookie_c + 8;

          // Try and release buffer, need to pass cookie to ffi call
          var buffer_release_c = @base + 150;
          var buffer_release_a = @base + 159;

          strb buffer_release_c, 0;

          strb buffer_release_c + 8, head;

          #try_buffer_release(buffer_release_c, 9, buffer_release_a, 1);
          var try_ret = ldb buffer_release_a;
          
          // Can't release buffer
          if try_ret <> 0 {
            return 1;
          }

          // Handling rollover
          head = head + 1;
          if head == 256 {
            head = 0;
          }
          
          if cnt == 0 {
            cnt = cnt - 1;
            rx_head = head;
            rx_remain = rx_remain + 1;
            var driver_enqueue_c = @base + 150;
            var driver_enqueue_a = @base + 158;

            // Place cookie into c array and enqueue the buffer it holds back into the control region
            strb driver_enqueue_c, complete_cookie;
            strb driver_enqueue_c + 1, complete_cookie + 1;
            strb driver_enqueue_c + 2, complete_cookie + 2;
            strb driver_enqueue_c + 3, complete_cookie + 3;
            strb driver_enqueue_c + 4, complete_cookie + 4;
            strb driver_enqueue_c + 5, complete_cookie + 5;
            strb driver_enqueue_c + 6, complete_cookie + 6;
            strb driver_enqueue_c + 7, complete_cookie + 7;

            #eth_driver_enqueue_avail(driver_enqueue_c, 8, driver_enqueue_a, 0);
          }
        }
      }
    }

    // Use addresses starting from 300
    if e & (1 << 25) {
      // Handle RX
      var head = rx_head;
      var num = 1;
      
      // Check if the ring is empty
      var ring_empty_c = @base + 300;
      var ring_empty_a = @base + 301;
      #eth_ring_empty(ring_empty_c, 0, ring_empty_a, 1);
      var was_empty = ldb ring_empty_a;
      var ring_empty_ret = ldb ring_empty_a;

      // Get the current ring size
      var ring_size_c = @base + 302;
      var ring_size_a = @base + 303;
      #eth_ring_size(ring_size_c, 0, ring_size_a, 1);
      var ring_size = ldb ring_size_a;

      while head <> rx_tail {
        if ring_size >= num {
          break;
        }

        // Check if the slot is marked as empty
        var check_empty_c = @base + 304;
        var check_empty_a = @base + 313;

        #check_empty(check_empty_c, 9, check_empty_a, 1);

        var check_empty_ret = ldb check_empty_a;
        
        if check_empty_ret == 1 {
          break;
        } 

        // Get the cookie at index head
        var get_cookie_c = @base + 314;
        var get_cookie_a = @base + 323;

        strb get_cookie_c, rx_cookies;
        strb get_cookie_c + 1, 1;

        strb get_cookie_c + 8, head;

        #get_cookies(get_cookie_c, 9, get_cookie_a, 0);

        head = head + 1;

        if head == rx_cnt {
          head = 0;
        }
        
        rx_head = head; 
        rx_remain = rx_remain + 1;

        var rx_enqueue_c = @base + 324;
        var rx_enqueue_a = @base + 332;

        strb rx_enqueue_c, ldb get_cookie_c;
        strb rx_enqueue_c + 1, ldb get_cookie_c + 1;
        strb rx_enqueue_c + 2, ldb get_cookie_c + 2;
        strb rx_enqueue_c + 3, ldb get_cookie_c + 3;
        strb rx_enqueue_c + 4, ldb get_cookie_c + 4;
        strb rx_enqueue_c + 5, ldb get_cookie_c + 5;
        strb rx_enqueue_c + 6, ldb get_cookie_c + 6;
        strb rx_enqueue_c + 7, ldb get_cookie_c + 7;

        #eth_driver_enqueue_avail(rx_enqueue_c, 8, rx_enqueue_a, 0);

        num = num + 1;

        #eth_ring_size(ring_size_c, 0, ring_size_a, 1);
        ring_size = ldb ring_size_a;
      }

      // Notify the client only if we have actually processed a packet. Not sure how this will work with pancake
      if num > 1 {
        if was_empty == 1 {
          #notify_rx(0,0,0,0);
        }
      }

      // Fill RX buf 
      #synchronise_call(c_arr, 0, a_arr, 0);
      while rx_remain > 0 {
          // Requesting a buffer
          var cookie = @base + 85;
          var phys = @base + 93;
          #alloc_rx_buff(cookie, 8, phys, 8);
          if phys <> 1 {
            break;
          }

          // This might not work if the machine word is 32 bits
          var stat = 1 << 58;
          var idx = rx_tail;
          var new_tail = idx + 1;
          if new_tail == rx_cnt {
            new_tail = 0;
            stat = stat | (1 << 13);
          }

          var set_cookie_c = @base + 101;
          var set_cookie_a = @base + 120;
          strb set_cookie_c, idx;

          // Setting bytes of cookie address
          strb set_cookie_c + 1, cookie;
          strb set_cookie_c + 2, cookie + 1;
          strb set_cookie_c + 3, cookie + 2;
          strb set_cookie_c + 4, cookie + 3;
          strb set_cookie_c + 5, cookie + 4;
          strb set_cookie_c + 6, cookie + 5;
          strb set_cookie_c + 7, cookie + 6;
          strb set_cookie_c + 8, cookie + 7;

          strb set_cookie_c + 9, 1;

          #set_cookies(set_cookie_c, 17, set_cookie_a, 0);

          var update_c = @base + 120;
          var update_a = @base + 148;

          // Storing descriptor in 0-7
          strb update_c + 0, 1;

          // Storing index in 8
          strb update_c + 8, index;

          // Storing phys in 9-16
          strb update_c + 9, phys;
          strb update_c + 10, phys + 1;
          strb update_c + 11, phys + 2;
          strb update_c + 12, phys + 3;
          strb update_c + 13, phys + 4;
          strb update_c + 14, phys + 5;
          strb update_c + 15, phys + 6;
          strb update_c + 16, phys + 7;

          // Storing len in 17
          strb update_c + 17, len;
          strb update_c + 18, len + 1;
          strb update_c + 19, len + 2;
          strb update_c + 20, len + 3;
          strb update_c + 21, len + 4;
          strb update_c + 22, len + 5;
          strb update_c + 23, len + 6;
          strb update_c + 24, len + 7;

          // Storing stat in 18 - 25
          strb update_c + 25, stat;
          strb update_c + 26, stat + 1;
          strb update_c + 27, stat + 2;
          strb update_c + 28, stat + 3;
          strb update_c + 29, stat + 4;
          strb update_c + 30, stat + 5;
          strb update_c + 31, stat + 6;
          strb update_c + 32, stat + 7;

          #update_descr_slot(update_c, 32, update_a, 0);
          rx_tail = new_tail;
          rx_remain = rx_remain - 1;
      }

      // Not sure if ffi protocol checks if we passed through valid addresses
      #synchronise_call(0, 0, 0, 0);

      if (rx_tail <> rx_head) {
        #enable_rx(0,0,0,0);
      }
    }

    if e & (1 << 22) {
      // Error here, infinitely loop
      while 1 == 1 {
        i = 1;
      }
    }

    // Get next IRQ here
    #get_irq(irq_c, 0, irq_a, 4);

    irq_num_1 = (ldb irq_a) << 24;
    irq_num_2 = (ldb irq_a + 1) << 16;
    irq_num_3 = (ldb irq_a + 2) << 8;
    irq_num_4 = (ldb irq_a + 3);

    e = irq_num_1 | irq_num_2 | irq_num_3 | irq_num_4;

  }

}

// Store tx and rx values

var set_rx_c = @base + 500;
var set_rx_a = @base + 504;
var set_tx_c = @base + 508;
var set_tx_a = @base + 512;

strb set_rx_c, rx_cnt;
strb set_rx_c + 1, rx_remain;
strb set_rx_c + 2, rx_tail;
strb set_rx_c + 3, rx_head;

#store_rx_vals(set_rx_c, 4, set_rx_a, 0);

strb set_tx_c, tx_cnt;
strb set_tx_c + 1, tx_remain;
strb set_tx_c + 2, tx_tail;
strb set_tx_c + 3, tx_head;

#store_tx_vals(set_tx_c, 4, set_tx_a, 0);


return 0;