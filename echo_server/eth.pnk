var rx_cnt = @base;
var rx_remain = @base + 4;
var rx_tail = @base + 8;
var rx_head = @base + 12;
var rx_phys = @base + 16;
var rx_cookies = @base + 24;
var rx_descr = @base + 32;

var tx_cnt = @base + 40;
var tx_remain = @base + 44;
var tx_tail = @base + 48;
var tx_head = @base + 52;
var tx_phys = @base + 56;
var tx_cookies = @base + 64;
var tx_descr = @base + 72;

var argc_arr = @base + 80;
var arga_arr = @base + 81;
#get_channel(argc_ar, 0, arga_arr, 1);
var argc = ldb arga_arr;

//base = 82

// Called from init entry point
if argc == -1 {
  rx_cnt = 256;
  rx_remain = 256 - 2;
  rx_tail = 0;
  rx_head = 0;

  var c_arr = @base + 82;
  #get_rx_phys(c_arr, 0, rx_phys, 8);
  #get_rx_cookies(c_arr, 0, rx_cookies, 8);
  #get_rx_descr(c_arr, 0, rx_descr, 8);

  tx_cnt = 256;
  tx_remain = 256 - 2;
  tx_tail = 0;
  tx_head = 0;

  #get_tx_phys(c_arr, 0, tx_phys, 8);
  #get_tx_cookies(c_arr, 0, tx_cookies, 8);
  #get_tx_descr(c_arr, 0, tx_cookies, 8);
}

//base = 83 - reuse the space c_arr above used

// INIT case from notified
if argc == 4 {
  var c_arr = @base + 83;
  var a_arr = @bae + 84;
  #init_post(c_arr, 0, a_arr, 0);
  
  //fill_rx_bufs() function:

  #sychronise_call(c_arr, 0, a_arr, 0);
  while rx_remain > 0 {
      // Requesting a buffer
      var cookie = @base + 85;
      var phys = @base + 93;
      #alloc_rx_buff(cookie, 8, phys, 8);
      if phys <> 1 {
        break;
      }

      // This might not work if the machine word is 32 bits
      var stat = 1 << 58;
      var idx = rx_tail;
      var new_tail = idx + 1;
      if new_tail == rx_cnt {
        new_tail = 0;
        stat = stat | (1 << 13);
      }

      var set_cookie_c = @base + 101;
      var set_cookie_a = @base + 120;
      strb set_cookie_c, idx;

      // Setting bytes of cookie address
      strb set_cookie_c + 1, cookie;
      strb set_cookie_c + 2, cookie + 1;
      strb set_cookie_c + 3, cookie + 2;
      strb set_cookie_c + 4, cookie + 3;
      strb set_cookie_c + 5, cookie + 4;
      strb set_cookie_c + 6, cookie + 5;
      strb set_cookie_c + 7, cookie + 6;
      strb set_cookie_c + 8, cookie + 7;

      strb set_cookie_c + 9, rx_cookies;
      strb set_cookie_c + 10, rx_cookies + 1;
      strb set_cookie_c + 11, rx_cookies + 2;
      strb set_cookie_c + 12, rx_cookies + 3;
      strb set_cookie_c + 13, rx_cookies + 4;
      strb set_cookie_c + 14, rx_cookies + 5;
      strb set_cookie_c + 15, rx_cookies + 6;
      strb set_cookie_c + 16, rx_cookies + 7;

      #set_cookies(set_cookie_c, 17, set_cookie_a, 0);

      var update_c = @base + 120;
      var update_a = @base + 148;

      // Storing descriptor in 0-7
      strb update_c + 0, rx_descr;
      strb update_c + 1, rx_descr + 1;
      strb update_c + 2, rx_descr + 2;
      strb update_c + 3, rx_descr + 3;
      strb update_c + 4, rx_descr + 4;
      strb update_c + 5, rx_descr + 5;
      strb update_c + 6, rx_descr + 6;
      strb update_c + 7, rx_descr + 7;

      // Storing index in 8
      strb update_c + 8, index;

      // Storing phys in 9-16
      strb update_c + 9, phys;
      strb update_c + 10, phys + 1;
      strb update_c + 11, phys + 2;
      strb update_c + 12, phys + 3;
      strb update_c + 13, phys + 4;
      strb update_c + 14, phys + 5;
      strb update_c + 15, phys + 6;
      strb update_c + 16, phys + 7;

      // Storing len in 17
      strb update_c + 17, 0;

      // Storing stat in 18 - 25
      strb update_c + 18, stat;
      strb update_c + 19, stat + 1;
      strb update_c + 20, stat + 2;
      strb update_c + 21, stat + 3;
      strb update_c + 22, stat + 4;
      strb update_c + 23, stat + 5;
      strb update_c + 24, stat + 6;
      strb update_c + 25, stat + 7;

      #update_descr_slot(update_c, 26, update_a, 0);
      rx_tail = new_tail;
      rx_remain = rx_remain - 1;
  }

  // Not sure if ffi protocol checks if we passed through valid addresses
  #sychronise_call(0, 0, 0, 0);

  if (rx_tail <> rx_head) {
    #enable_rx(0,0,0,0);
  }

}

// Handle TX case
if argc == 2 {
  var dequeue_c = @base + 83;
  strb dequeue_c, 1;
  // dequeue_a will be 24 in size
  var dequeue_a = @base + 84;

  #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

  var driver_ret = ldb dequeue_c;

  var buffer = @base + 84;
  var len = @base + 92;
  var cookie = @base + 100;

  while tx_remain > 1 {
    if driver_dequeue == 1 {
      break;
    }

    var phys = @base + 108;
    #get_phys(buffer, 8, phys, 8);

    // Handle the raw_tx function here
    if rx_remain < 1 {
      // Complete TX function here

      if rx_remain < 1 {
        // TX queue lacks space
        return;
      }

    }

    #sychronise_call(0,0,0,0);
    var tail = rx_tail;
    var tail_new = tail;
    var i = 1;
    while i > 0 {
      i = i - 1;
      var stat = (1 << 15);
      if (i == 0) {
        stat = stat | (1 << 10) | (1 << 11);
      }

      var index = tail_new;
      
      if tail_new + 1 == 256 {
        tail_new = 0;
        stat = stat | (1 << 13);
      } 

      // update the ring slot
    }

    // Set the cookie 
    var set_cookie_c = @base + 109;
    var set_cookie_a = @base + 126;
    strb set_cookie_c, index;

    // Setting bytes of cookie address
    strb set_cookie_c + 1, cookie;
    strb set_cookie_c + 2, cookie + 1;
    strb set_cookie_c + 3, cookie + 2;
    strb set_cookie_c + 4, cookie + 3;
    strb set_cookie_c + 5, cookie + 4;
    strb set_cookie_c + 6, cookie + 5;
    strb set_cookie_c + 7, cookie + 6;
    strb set_cookie_c + 8, cookie + 7;

    strb set_cookie_c + 9, tx_cookies;
    strb set_cookie_c + 10, tx_cookies + 1;
    strb set_cookie_c + 11, tx_cookies + 2;
    strb set_cookie_c + 12, tx_cookies + 3;
    strb set_cookie_c + 13, tx_cookies + 4;
    strb set_cookie_c + 14, tx_cookies + 5;
    strb set_cookie_c + 15, tx_cookies + 6;
    strb set_cookie_c + 16, tx_cookies + 7;

    #set_cookies(set_cookie_c, 17, set_cookie_a, 0);

    // Dequeue another buffer to service
    var dequeue_c = @base + 83;
    strb dequeue_c, 1;
    // dequeue_a will be 24 in size
    var dequeue_a = @base + 84;

    #eth_driver_dequeue_used(dequeue_c, 1, dequeue_a, 24);

    var driver_ret = ldb dequeue_c;
  }

}